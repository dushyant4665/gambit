const { chromium } = require('playwright')
describe('Chess Game Integration Tests', () => {
  let browser, player1Page, player2Page
  let roomCode = ''
  beforeAll(async () => {
    browser = await chromium.launch({ headless: false, slowMo: 100 })
  })
  afterAll(async () => {
    await browser.close()
  })
  beforeEach(async () => {
    const context1 = await browser.newContext()
    const context2 = await browser.newContext()
    player1Page = await context1.newPage()
    player2Page = await context2.newPage()
    await player1Page.goto('http:
    await player2Page.goto('http:
  })
  afterEach(async () => {
    await player1Page.close()
    await player2Page.close()
  })
  test('Complete game flow: create room, join, make moves', async () => {
    await player1Page.fill('input[placeholder*="name"]', 'Alice')
    await player1Page.click('button:has-text("Create Room")')
    await player1Page.waitForSelector('h1:has-text("Room:")')
    const roomText = await player1Page.textContent('h1')
    roomCode = roomText.split('Room: ')[1]
    console.log('Room created:', roomCode)
    await expect(player1Page.locator('text=Waiting for Player 2')).toBeVisible()
    await player2Page.fill('input[placeholder*="name"]', 'Bob')
    await player2Page.click('button:has-text("Join Room")')
    await player2Page.fill('input[placeholder*="room code"]', roomCode)
    await player2Page.click('button:has-text("Join")')
    await player2Page.waitForSelector('h1:has-text("Room:")')
    await expect(player1Page.locator('text=Player Connected!')).toBeVisible({ timeout: 5000 })
    await player1Page.waitForSelector('text=Alice\'s turn', { timeout: 5000 })
    await player2Page.waitForSelector('text=Alice\'s turn', { timeout: 5000 })
    console.log('Both players connected, game started')
    const player1Board = player1Page.locator('[data-testid="chessboard"]').first()
    await player1Board.dragAndDrop('[data-square="e2"]', '[data-square="e4"]')
    await expect(player1Page.locator('text=Bob\'s turn')).toBeVisible({ timeout: 1000 })
    await expect(player2Page.locator('text=Bob\'s turn')).toBeVisible({ timeout: 1000 })
    console.log('First move successful: e2-e4')
    const player2Board = player2Page.locator('[data-testid="chessboard"]').first()
    await player2Board.dragAndDrop('[data-square="e7"]', '[data-square="e5"]')
    await expect(player1Page.locator('text=Alice\'s turn')).toBeVisible({ timeout: 1000 })
    await expect(player2Page.locator('text=Alice\'s turn')).toBeVisible({ timeout: 1000 })
    console.log('Second move successful: e7-e5')
    await player1Board.dragAndDrop('[data-square="e5"]', '[data-square="e6"]')
    await expect(player1Page.locator('text=Alice\'s turn')).toBeVisible({ timeout: 500 })
    console.log('Invalid move correctly rejected')
    await expect(player1Page.locator('text=Moves: 2')).toBeVisible()
    await expect(player2Page.locator('text=Moves: 2')).toBeVisible()
    console.log('Move count correct: 2 moves')
  }, 30000) 
  test('Room persistence: refresh and reconnect', async () => {
    await player1Page.fill('input[placeholder*="name"]', 'Alice')
    await player1Page.click('button:has-text("Create Room")')
    const roomText = await player1Page.textContent('h1')
    roomCode = roomText.split('Room: ')[1]
    await player2Page.fill('input[placeholder*="name"]', 'Bob')
    await player2Page.click('button:has-text("Join Room")')
    await player2Page.fill('input[placeholder*="room code"]', roomCode)
    await player2Page.click('button:has-text("Join")')
    await player1Page.waitForSelector('text=Alice\'s turn', { timeout: 5000 })
    const player1Board = player1Page.locator('[data-testid="chessboard"]').first()
    await player1Board.dragAndDrop('[data-square="e2"]', '[data-square="e4"]')
    await expect(player1Page.locator('text=Bob\'s turn')).toBeVisible({ timeout: 1000 })
    await player1Page.reload()
    await player1Page.goto(`http:
    await expect(player1Page.locator('text=Bob\'s turn')).toBeVisible({ timeout: 5000 })
    await expect(player1Page.locator('text=Moves: 1')).toBeVisible()
    console.log('Game state preserved after refresh')
  }, 20000)
  test('Optimistic UI updates and rollback', async () => {
    await player1Page.fill('input[placeholder*="name"]', 'Alice')
    await player1Page.click('button:has-text("Create Room")')
    const roomText = await player1Page.textContent('h1')
    roomCode = roomText.split('Room: ')[1]
    await player2Page.fill('input[placeholder*="name"]', 'Bob')
    await player2Page.click('button:has-text("Join Room")')
    await player2Page.fill('input[placeholder*="room code"]', roomCode)
    await player2Page.click('button:has-text("Join")')
    await player1Page.waitForSelector('text=Alice\'s turn', { timeout: 5000 })
    const player1Board = player1Page.locator('[data-testid="chessboard"]').first()
    await player1Board.hover('[data-square="e2"]')
    await player1Page.mouse.down()
    await player1Board.hover('[data-square="e4"]')
    await player1Page.mouse.up()
    const startTime = Date.now()
    await expect(player2Page.locator('text=Bob\'s turn')).toBeVisible({ timeout: 1000 })
    const endTime = Date.now()
    expect(endTime - startTime).toBeLessThan(1000) 
    console.log('Optimistic update completed in', endTime - startTime, 'ms')
  }, 15000)
})
if (require.main === module) {
  console.log('Running integration tests...')
  console.log('Make sure both client (localhost:3000) and server (localhost:3001) are running')
}
